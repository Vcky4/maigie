"""
Action Service.
Executes structured actions triggered by the AI (e.g., creating courses).
"""

import json

from prisma import Prisma
from prisma.models import User

db = Prisma()


class ActionService:
    async def execute_action(self, action_type: str, action_data: dict, user_id: str):
        """
        Route the action to the correct handler.
        """
        print(f"‚ö° EXECUTING ACTION: {action_type} for User {user_id}")

        if not db.is_connected():
            await db.connect()

        if action_type == "create_course":
            return await self.create_course(action_data, user_id)
        elif action_type == "create_note":
            return await self.create_note(action_data, user_id)
        elif action_type == "retake_note":
            return await self.retake_note(action_data, user_id)
        elif action_type == "add_summary":
            return await self.add_summary(action_data, user_id)

        # Add more actions here later (create_goal, create_schedule, etc.)
        return {"status": "error", "message": f"Unknown action: {action_type}"}

    async def create_course(self, data: dict, user_id: str):
        """
        Creates a course with modules and topics in the DB.
        Expected data: { "title": "...", "modules": [ { "title": "...", "topics": [...] } ] }
        """
        try:
            # 1. Create the Course
            course = await db.course.create(
                data={
                    "userId": user_id,
                    "title": data.get("title", "AI Generated Course"),
                    "description": data.get("description", "Generated by Maigie AI"),
                    "difficulty": data.get("difficulty", "BEGINNER"),
                    "isAIGenerated": True,
                }
            )

            # 2. Create Modules and Topics (Nested loop)
            modules_data = data.get("modules", [])
            for i, mod_data in enumerate(modules_data):
                module = await db.module.create(
                    data={
                        "courseId": course.id,
                        "title": mod_data.get("title", f"Module {i+1}"),
                        "order": float(i),
                    }
                )

                # Create Topics for this Module
                topics_data = mod_data.get("topics", [])
                for j, top_data in enumerate(topics_data):
                    await db.topic.create(
                        data={
                            "moduleId": module.id,
                            "title": (
                                top_data if isinstance(top_data, str) else top_data.get("title")
                            ),
                            "order": float(j),
                        }
                    )

            return {
                "status": "success",
                "action": "create_course",
                "course_id": course.id,
                "message": f"Successfully created course: {course.title}",
            }

        except Exception as e:
            print(f"‚ùå Action Failed: {e}")
            return {"status": "error", "message": str(e)}

    async def create_note(self, data: dict, user_id: str):
        """
        Creates a note for a topic.
        Expected data: { "title": "...", "content": "...", "topicId": "...", "summary": "..." (optional) }
        """
        try:
            from src.services import note_service
            from src.models.notes import NoteCreate

            # Validate topicId if provided
            topic_id = data.get("topicId")
            if topic_id:
                print(f"üîç Looking up topic with ID: {topic_id}")
                topic = await db.topic.find_unique(where={"id": topic_id})
                if not topic:
                    # Try to find any topic to see if it's a database issue
                    all_topics = await db.topic.find_many(take=1)
                    print(f"üîç Database has {len(all_topics)} topics (showing first as sample)")
                    if all_topics:
                        print(f"üîç Sample topic ID format: {all_topics[0].id}")
                    return {"status": "error", "message": f"Topic with ID {topic_id} not found"}

                # Check if note already exists for this topic
                existing_note = await db.note.find_first(where={"topicId": topic_id})
                if existing_note:
                    return {
                        "status": "error",
                        "message": f"A note already exists for topic: {topic.title}",
                    }

            # Create note data
            note_data = NoteCreate(
                title=data.get("title", "Untitled Note"),
                content=data.get("content", ""),
                summary=data.get("summary"),
                topicId=topic_id,
                courseId=data.get("courseId"),
            )

            # Create the note
            note = await note_service.create_note(db, user_id, note_data)

            return {
                "status": "success",
                "action": "create_note",
                "note_id": note.id,
                "message": f"Successfully created note: {note.title}",
            }

        except ValueError as e:
            print(f"‚ùå Note Creation Failed: {e}")
            return {"status": "error", "message": str(e)}
        except Exception as e:
            print(f"‚ùå Note Creation Error: {e}")
            return {"status": "error", "message": str(e)}

    async def retake_note(self, data: dict, user_id: str):
        """
        Retake/rewrite a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service
            from src.models.notes import NoteUpdate

            note_id = data.get("noteId")
            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            # Get the note
            note = await db.note.find_unique(where={"id": note_id})
            if not note:
                return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to retake"}

            # Build context for AI
            context = {}
            if note.topicId:
                topic = await db.topic.find_unique(
                    where={"id": note.topicId}, include={"module": {"include": {"course": True}}}
                )
                if topic:
                    context["topicTitle"] = topic.title
                    if topic.module:
                        context["moduleTitle"] = topic.module.title
                        if topic.module.course:
                            context["courseTitle"] = topic.module.course.title

            # Use AI to rewrite the content
            rewritten_content = await llm_service.rewrite_note_content(
                content=note.content, title=note.title, context=context
            )

            # Update the note
            updated_note = await db.note.update(
                where={"id": note_id}, data={"content": rewritten_content}
            )

            return {
                "status": "success",
                "action": "retake_note",
                "note_id": updated_note.id,
                "message": f"Successfully retook note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Retake Note Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_summary(self, data: dict, user_id: str):
        """
        Add a summary to a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service

            note_id = data.get("noteId")
            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            # Get the note
            note = await db.note.find_unique(where={"id": note_id})
            if not note:
                return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to summarize"}

            # Generate summary using AI
            summary = await llm_service.generate_summary(note.content)

            # Append summary to content
            summary_section = "\n\n---\n\n## Summary\n\n" + summary
            updated_content = note.content + summary_section

            # Update the note
            updated_note = await db.note.update(
                where={"id": note_id}, data={"content": updated_content}
            )

            return {
                "status": "success",
                "action": "add_summary",
                "note_id": updated_note.id,
                "message": f"Successfully added summary to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Summary Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}


# Global Instance
action_service = ActionService()
