"""
Action Service.
Executes structured actions triggered by the AI (e.g., creating courses).
"""

import json
import re

from prisma.models import User
from src.core.database import db


class ActionService:
    async def execute_action(self, action_type: str, action_data: dict, user_id: str):
        """
        Route the action to the correct handler.
        """
        print(f"‚ö° EXECUTING ACTION: {action_type} for User {user_id}")

        if action_type == "create_course":
            return await self.create_course(action_data, user_id)
        elif action_type == "create_note":
            return await self.create_note(action_data, user_id)
        elif action_type == "retake_note":
            return await self.retake_note(action_data, user_id)
        elif action_type == "add_summary":
            return await self.add_summary(action_data, user_id)
        elif action_type == "add_tags":
            return await self.add_tags(action_data, user_id)
        elif action_type == "recommend_resources":
            return await self.recommend_resources(action_data, user_id)

        # Add more actions here later (create_goal, create_schedule, etc.)
        return {"status": "error", "message": f"Unknown action: {action_type}"}

    async def create_course(self, data: dict, user_id: str):
        """
        Creates a course with modules and topics in the DB.
        Expected data: { "title": "...", "modules": [ { "title": "...", "topics": [...] } ] }
        """
        try:
            # 1. Create the Course
            course = await db.course.create(
                data={
                    "userId": user_id,
                    "title": data.get("title", "AI Generated Course"),
                    "description": data.get("description", "Generated by Maigie AI"),
                    "difficulty": data.get("difficulty", "BEGINNER"),
                    "isAIGenerated": True,
                }
            )

            # 2. Create Modules and Topics (Nested loop)
            modules_data = data.get("modules", [])
            for i, mod_data in enumerate(modules_data):
                module = await db.module.create(
                    data={
                        "courseId": course.id,
                        "title": mod_data.get("title", f"Module {i+1}"),
                        "order": float(i),
                    }
                )

                # Create Topics for this Module
                topics_data = mod_data.get("topics", [])
                for j, top_data in enumerate(topics_data):
                    await db.topic.create(
                        data={
                            "moduleId": module.id,
                            "title": (
                                top_data if isinstance(top_data, str) else top_data.get("title")
                            ),
                            "order": float(j),
                        }
                    )

            return {
                "status": "success",
                "action": "create_course",
                "course_id": course.id,
                "message": f"Successfully created course: {course.title}",
            }

        except Exception as e:
            print(f"‚ùå Action Failed: {e}")
            return {"status": "error", "message": str(e)}

    async def create_note(self, data: dict, user_id: str):
        """
        Creates a note for a topic.
        Expected data: { "title": "...", "content": "...", "topicId": "...", "summary": "..." (optional) }
        """
        try:
            from src.services import note_service
            from src.models.notes import NoteCreate

            # Validate topicId if provided
            topic_id = data.get("topicId")
            if topic_id:
                print(f"üîç Looking up topic with ID: {topic_id}")
                topic = await db.topic.find_unique(where={"id": topic_id})
                if not topic:
                    # Try to find any topic to see if it's a database issue
                    all_topics = await db.topic.find_many(take=1)
                    print(f"üîç Database has {len(all_topics)} topics (showing first as sample)")
                    if all_topics:
                        print(f"üîç Sample topic ID format: {all_topics[0].id}")
                    return {"status": "error", "message": f"Topic with ID {topic_id} not found"}

                # Check if note already exists for this topic
                existing_note = await db.note.find_first(where={"topicId": topic_id})
                if existing_note:
                    return {
                        "status": "error",
                        "message": f"A note already exists for topic: {topic.title}",
                    }

            # Create note data
            note_data = NoteCreate(
                title=data.get("title", "Untitled Note"),
                content=data.get("content", ""),
                summary=data.get("summary"),
                topicId=topic_id,
                courseId=data.get("courseId"),
            )

            # Create the note
            note = await note_service.create_note(db, user_id, note_data)

            return {
                "status": "success",
                "action": "create_note",
                "note_id": note.id,
                "message": f"Successfully created note: {note.title}",
            }

        except ValueError as e:
            print(f"‚ùå Note Creation Failed: {e}")
            return {"status": "error", "message": str(e)}
        except Exception as e:
            print(f"‚ùå Note Creation Error: {e}")
            return {"status": "error", "message": str(e)}

    async def retake_note(self, data: dict, user_id: str):
        """
        Retake/rewrite a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service
            from src.models.notes import NoteUpdate

            note_id = data.get("noteId")
            print(f"üì• Received action_data: {data}")
            print(f"üîç Extracted noteId: {note_id}")
            print(f"üë§ User ID: {user_id}")

            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            print(f"üîç Looking up note with ID: {note_id}")
            # Get the note
            note = await db.note.find_unique(where={"id": note_id})
            if note:
                print(f"‚úÖ Note found: {note.id} (title: {note.title}, userId: {note.userId})")
            else:
                print(f"‚ùå Note NOT FOUND with ID: {note_id}")

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic:
                    if topic.note:
                        # It's a topicId, use the topic's note
                        print(
                            f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}"
                        )
                        note = topic.note
                        note_id = note.id  # Update note_id to the actual note ID
                    else:
                        # Topic exists but has no note
                        return {
                            "status": "error",
                            "message": f"Topic '{topic.title}' exists but has no note. Please create a note first.",
                        }
                else:
                    return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to retake"}

            # Build context for AI
            context = {}
            if note.topicId:
                topic = await db.topic.find_unique(
                    where={"id": note.topicId}, include={"module": {"include": {"course": True}}}
                )
                if topic:
                    context["topicTitle"] = topic.title
                    if topic.module:
                        context["moduleTitle"] = topic.module.title
                        if topic.module.course:
                            context["courseTitle"] = topic.module.course.title
                            context["courseId"] = (
                                topic.module.course.id
                            )  # Include courseId from module->course

            # Strip any action blocks from the original content before rewriting
            cleaned_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                note.content,
                flags=re.DOTALL,
            ).strip()

            # Use AI to rewrite the content
            rewritten_content = await llm_service.rewrite_note_content(
                content=cleaned_content, title=note.title, context=context
            )

            # Strip any action blocks from the rewritten content (in case AI includes them)
            rewritten_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                rewritten_content,
                flags=re.DOTALL,
            ).strip()

            # Update the note
            updated_note = await db.note.update(
                where={"id": note_id}, data={"content": rewritten_content}
            )

            return {
                "status": "success",
                "action": "retake_note",
                "note_id": updated_note.id,
                "message": f"Successfully retook note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Retake Note Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_summary(self, data: dict, user_id: str):
        """
        Add a summary to a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service

            note_id = data.get("noteId")
            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            # Get the note
            note = await db.note.find_unique(where={"id": note_id})

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic and topic.note:
                    # It's a topicId, use the topic's note
                    print(f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}")
                    note = topic.note
                    note_id = note.id  # Update note_id to the actual note ID
                else:
                    return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to summarize"}

            # Strip any action blocks from content before summarizing
            cleaned_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                note.content,
                flags=re.DOTALL,
            ).strip()

            # Generate summary using AI
            summary = await llm_service.generate_summary(cleaned_content)

            # Update the note with summary in the summary field
            updated_note = await db.note.update(where={"id": note_id}, data={"summary": summary})

            return {
                "status": "success",
                "action": "add_summary",
                "note_id": updated_note.id,
                "message": f"Successfully added summary to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Summary Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_tags(self, data: dict, user_id: str):
        """
        Add tags to a note using AI.
        Expected data: { "noteId": "...", "tags": ["Tag1", "Tag2"] } (tags optional, will be generated if not provided)
        """
        try:
            from src.services.llm_service import llm_service
            from src.models.notes import NoteUpdate

            note_id = data.get("noteId")
            print(f"üì• Received action_data for add_tags: {data}")
            print(f"üîç Extracted noteId: {note_id}")
            print(f"üë§ User ID: {user_id}")

            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            print(f"üîç Looking up note with ID: {note_id}")
            # Get the note
            note = await db.note.find_unique(
                where={"id": note_id},
                include={
                    "tags": True,
                    "topic": {"include": {"module": {"include": {"course": True}}}},
                },
            )

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic:
                    if topic.note:
                        print(
                            f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}"
                        )
                        note = await db.note.find_unique(
                            where={"id": topic.note.id},
                            include={
                                "tags": True,
                                "topic": {"include": {"module": {"include": {"course": True}}}},
                            },
                        )
                        note_id = note.id if note else None
                    else:
                        return {
                            "status": "error",
                            "message": f"Topic '{topic.title}' exists but has no note. Please create a note first.",
                        }
                else:
                    return {"status": "error", "message": f"Note with ID {note_id} not found"}

            if not note:
                return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            # Get existing tags
            existing_tags = [tag.tag for tag in note.tags] if note.tags else []
            print(f"üìã Existing tags: {existing_tags}")

            # Get tags from action data or generate them
            new_tags = data.get("tags")
            if not new_tags:
                # Generate tags using AI
                print("ü§ñ Generating tags using AI...")
                topic_title = None
                if note.topic:
                    topic_title = note.topic.title

                new_tags = await llm_service.generate_tags(
                    content=note.content or "",
                    title=note.title,
                    topic_title=topic_title,
                )
                print(f"‚ú® AI generated tags: {new_tags}")

            # Merge tags (avoid duplicates, case-insensitive)
            existing_lower = [t.lower() for t in existing_tags]
            merged_tags = existing_tags.copy()
            for tag in new_tags:
                if tag.lower() not in existing_lower:
                    merged_tags.append(tag)

            print(f"üìù Merged tags: {merged_tags}")

            # Update the note with merged tags
            # Remove existing tags
            await db.notetag.delete_many(where={"noteId": note_id})

            # Add merged tags
            for tag in merged_tags:
                await db.notetag.create(
                    data={
                        "noteId": note_id,
                        "tag": tag,
                    }
                )

            # Fetch updated note
            from src.services import note_service

            updated_note = await note_service.get_note(db, note_id, user_id)

            return {
                "status": "success",
                "action": "add_tags",
                "note_id": updated_note.id,
                "tags": merged_tags,
                "message": f"Successfully added tags to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Tags Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def recommend_resources(self, data: dict, user_id: str):
        """
        Generate and store resource recommendations using RAG.
        Expected data: { "query": "...", "topicId": "..." (optional), "courseId": "..." (optional), "limit": 10 }
        """
        try:
            from src.services.rag_service import rag_service
            from src.services.user_memory_service import user_memory_service

            query = data.get("query", "")
            topic_id = data.get("topicId")
            course_id = data.get("courseId")
            limit = data.get("limit", 10)

            if not query:
                return {
                    "status": "error",
                    "message": "Query is required for resource recommendations",
                }

            # Get user context
            user_context = await user_memory_service.get_user_context(user_id)

            # Add topic/course context if provided
            if topic_id:
                topic = await db.topic.find_unique(
                    where={"id": topic_id}, include={"module": {"include": {"course": True}}}
                )
                if topic:
                    user_context["currentTopic"] = {
                        "id": topic.id,
                        "title": topic.title,
                        "content": topic.content,
                    }
                    if topic.module and topic.module.course:
                        course_id = topic.module.course.id
                        user_context["currentCourse"] = {
                            "id": topic.module.course.id,
                            "title": topic.module.course.title,
                        }

            if course_id and "currentCourse" not in user_context:
                course = await db.course.find_unique(where={"id": course_id})
                if course:
                    user_context["currentCourse"] = {
                        "id": course.id,
                        "title": course.title,
                    }

            # Generate recommendations using RAG
            recommendations = await rag_service.generate_recommendations(
                query=query,
                user_id=user_id,
                user_context=user_context,
                limit=limit,
            )

            # Validate user_id
            if not user_id:
                return {
                    "status": "error",
                    "message": "User ID is required for resource recommendations",
                }

            # Verify user exists
            user = await db.user.find_unique(where={"id": user_id})
            if not user:
                return {
                    "status": "error",
                    "message": f"User with ID {user_id} not found",
                }

            # Validate recommendations
            if not recommendations or not isinstance(recommendations, list):
                return {
                    "status": "error",
                    "message": "No recommendations generated",
                }

            # Store recommendations as resources
            stored_resources = []
            for rec in recommendations:
                # Build recommendation reason
                reason_parts = []
                if topic_id:
                    topic_title = user_context.get("currentTopic", {}).get("title", "this topic")
                    reason_parts.append(f"for {topic_title}")
                elif course_id:
                    course_title = user_context.get("currentCourse", {}).get("title", "this course")
                    reason_parts.append(f"related to {course_title}")
                reason = " ".join(reason_parts) if reason_parts else None

                # Build metadata - ensure it's a valid JSON-serializable dict or None
                relevance = rec.get("relevance")
                metadata = None
                if relevance is not None and relevance != "":
                    # Only create metadata if relevance has a valid value
                    # Ensure it's JSON-serializable
                    try:
                        json.dumps({"relevance": str(relevance)})  # Validate JSON serialization
                        metadata = {"relevance": str(relevance)}
                    except (TypeError, ValueError):
                        metadata = None

                # Prepare resource data - ensure all required fields are set
                title = rec.get("title", "Untitled") or "Untitled"
                url = rec.get("url", "") or ""

                if not url:
                    print(f"‚ö†Ô∏è Skipping resource with empty URL: {title}")
                    continue

                # Validate and normalize resource type
                resource_type = rec.get("type", "OTHER") or "OTHER"
                valid_types = [
                    "VIDEO",
                    "ARTICLE",
                    "BOOK",
                    "COURSE",
                    "DOCUMENT",
                    "WEBSITE",
                    "PODCAST",
                    "OTHER",
                ]
                if resource_type.upper() not in valid_types:
                    resource_type = "OTHER"

                # Validate and convert score to float
                try:
                    score = float(rec.get("score", 0.5))
                    # Ensure score is between 0 and 1
                    score = max(0.0, min(1.0, score))
                except (ValueError, TypeError):
                    score = 0.5

                resource_data = {
                    "userId": user_id,
                    "title": title,
                    "url": url,
                    "description": rec.get("description"),
                    "type": resource_type.upper(),
                    "isRecommended": True,
                    "recommendationScore": score,
                    "recommendationSource": "ai",
                }

                # Add optional fields only if they have values
                if reason:
                    resource_data["recommendationReason"] = reason
                if course_id:
                    resource_data["courseId"] = course_id
                if topic_id:
                    resource_data["topicId"] = topic_id
                # Always include metadata (can be None) - matches resources.py pattern
                resource_data["metadata"] = metadata

                try:
                    resource = await db.resource.create(data=resource_data)

                    stored_resources.append(
                        {
                            "id": resource.id,
                            "title": resource.title,
                            "url": resource.url,
                            "description": resource.description,
                            "type": resource.type,
                            "score": score,
                        }
                    )

                    # Index the resource in the background (don't fail if indexing fails)
                    try:
                        from src.services.indexing_service import indexing_service

                        await indexing_service.index_resource(resource.id)
                    except Exception as indexing_error:
                        print(f"‚ö†Ô∏è Failed to index resource {resource.id}: {indexing_error}")
                        # Continue processing other resources

                except Exception as create_error:
                    print(f"‚ö†Ô∏è Failed to create resource '{title}': {create_error}")
                    # Continue processing other resources
                    continue

            # Record interaction (don't fail if this fails)
            try:
                await user_memory_service.record_interaction(
                    user_id=user_id,
                    interaction_type="RECOMMENDATION_REQUESTED",
                    entity_type="chat",
                    metadata={
                        "query": query,
                        "recommendationCount": len(stored_resources),
                        "topicId": topic_id,
                        "courseId": course_id,
                    },
                    importance=0.7,
                )
            except Exception as interaction_error:
                print(f"‚ö†Ô∏è Failed to record interaction: {interaction_error}")
                # Continue - this is not critical

            # Return success even if some resources failed to create
            if not stored_resources:
                return {
                    "status": "error",
                    "message": "No resources could be created from recommendations",
                }

            return {
                "status": "success",
                "action": "recommend_resources",
                "resources": stored_resources,
                "count": len(stored_resources),
                "message": f"Successfully generated {len(stored_resources)} resource recommendations",
            }

        except Exception as e:
            print(f"‚ùå Recommend Resources Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}


# Global Instance
action_service = ActionService()
