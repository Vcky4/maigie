"""
Action Service.
Executes structured actions triggered by the AI (e.g., creating courses).
"""

import json
import re

from prisma.models import User
from src.core.database import db


class ActionService:
    async def execute_action(self, action_type: str, action_data: dict, user_id: str):
        """
        Route the action to the correct handler.
        """
        print(f"‚ö° EXECUTING ACTION: {action_type} for User {user_id}")

        if action_type == "create_course":
            return await self.create_course(action_data, user_id)
        elif action_type == "create_note":
            return await self.create_note(action_data, user_id)
        elif action_type == "retake_note":
            return await self.retake_note(action_data, user_id)
        elif action_type == "add_summary":
            return await self.add_summary(action_data, user_id)
        elif action_type == "add_tags":
            return await self.add_tags(action_data, user_id)
        elif action_type == "recommend_resources":
            return await self.recommend_resources(action_data, user_id)

        # Add more actions here later (create_goal, create_schedule, etc.)
        return {"status": "error", "message": f"Unknown action: {action_type}"}

    async def create_course(self, data: dict, user_id: str):
        """
        Creates a course with modules and topics in the DB.
        Expected data: { "title": "...", "modules": [ { "title": "...", "topics": [...] } ] }
        """
        try:
            # 1. Create the Course
            course = await db.course.create(
                data={
                    "userId": user_id,
                    "title": data.get("title", "AI Generated Course"),
                    "description": data.get("description", "Generated by Maigie AI"),
                    "difficulty": data.get("difficulty", "BEGINNER"),
                    "isAIGenerated": True,
                }
            )

            # 2. Create Modules and Topics (Nested loop)
            modules_data = data.get("modules", [])
            for i, mod_data in enumerate(modules_data):
                module = await db.module.create(
                    data={
                        "courseId": course.id,
                        "title": mod_data.get("title", f"Module {i+1}"),
                        "order": float(i),
                    }
                )

                # Create Topics for this Module
                topics_data = mod_data.get("topics", [])
                for j, top_data in enumerate(topics_data):
                    await db.topic.create(
                        data={
                            "moduleId": module.id,
                            "title": (
                                top_data if isinstance(top_data, str) else top_data.get("title")
                            ),
                            "order": float(j),
                        }
                    )

            return {
                "status": "success",
                "action": "create_course",
                "course_id": course.id,
                "message": f"Successfully created course: {course.title}",
            }

        except Exception as e:
            print(f"‚ùå Action Failed: {e}")
            return {"status": "error", "message": str(e)}

    async def create_note(self, data: dict, user_id: str):
        """
        Creates a note for a topic.
        Expected data: { "title": "...", "content": "...", "topicId": "...", "summary": "..." (optional) }
        """
        try:
            from src.services import note_service
            from src.models.notes import NoteCreate

            # Validate topicId if provided
            topic_id = data.get("topicId")
            if topic_id:
                print(f"üîç Looking up topic with ID: {topic_id}")
                topic = await db.topic.find_unique(where={"id": topic_id})
                if not topic:
                    # Try to find any topic to see if it's a database issue
                    all_topics = await db.topic.find_many(take=1)
                    print(f"üîç Database has {len(all_topics)} topics (showing first as sample)")
                    if all_topics:
                        print(f"üîç Sample topic ID format: {all_topics[0].id}")
                    return {"status": "error", "message": f"Topic with ID {topic_id} not found"}

                # Check if note already exists for this topic
                existing_note = await db.note.find_first(where={"topicId": topic_id})
                if existing_note:
                    return {
                        "status": "error",
                        "message": f"A note already exists for topic: {topic.title}",
                    }

            # Create note data
            note_data = NoteCreate(
                title=data.get("title", "Untitled Note"),
                content=data.get("content", ""),
                summary=data.get("summary"),
                topicId=topic_id,
                courseId=data.get("courseId"),
            )

            # Create the note
            note = await note_service.create_note(db, user_id, note_data)

            return {
                "status": "success",
                "action": "create_note",
                "note_id": note.id,
                "message": f"Successfully created note: {note.title}",
            }

        except ValueError as e:
            print(f"‚ùå Note Creation Failed: {e}")
            return {"status": "error", "message": str(e)}
        except Exception as e:
            print(f"‚ùå Note Creation Error: {e}")
            return {"status": "error", "message": str(e)}

    async def retake_note(self, data: dict, user_id: str):
        """
        Retake/rewrite a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service
            from src.models.notes import NoteUpdate

            note_id = data.get("noteId")
            print(f"üì• Received action_data: {data}")
            print(f"üîç Extracted noteId: {note_id}")
            print(f"üë§ User ID: {user_id}")

            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            print(f"üîç Looking up note with ID: {note_id}")
            # Get the note
            note = await db.note.find_unique(where={"id": note_id})
            if note:
                print(f"‚úÖ Note found: {note.id} (title: {note.title}, userId: {note.userId})")
            else:
                print(f"‚ùå Note NOT FOUND with ID: {note_id}")

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic:
                    if topic.note:
                        # It's a topicId, use the topic's note
                        print(
                            f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}"
                        )
                        note = topic.note
                        note_id = note.id  # Update note_id to the actual note ID
                    else:
                        # Topic exists but has no note
                        return {
                            "status": "error",
                            "message": f"Topic '{topic.title}' exists but has no note. Please create a note first.",
                        }
                else:
                    return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to retake"}

            # Build context for AI
            context = {}
            if note.topicId:
                topic = await db.topic.find_unique(
                    where={"id": note.topicId}, include={"module": {"include": {"course": True}}}
                )
                if topic:
                    context["topicTitle"] = topic.title
                    if topic.module:
                        context["moduleTitle"] = topic.module.title
                        if topic.module.course:
                            context["courseTitle"] = topic.module.course.title
                            context["courseId"] = (
                                topic.module.course.id
                            )  # Include courseId from module->course

            # Strip any action blocks from the original content before rewriting
            cleaned_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                note.content,
                flags=re.DOTALL,
            ).strip()

            # Use AI to rewrite the content
            rewritten_content = await llm_service.rewrite_note_content(
                content=cleaned_content, title=note.title, context=context
            )

            # Strip any action blocks from the rewritten content (in case AI includes them)
            rewritten_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                rewritten_content,
                flags=re.DOTALL,
            ).strip()

            # Update the note
            updated_note = await db.note.update(
                where={"id": note_id}, data={"content": rewritten_content}
            )

            return {
                "status": "success",
                "action": "retake_note",
                "note_id": updated_note.id,
                "message": f"Successfully retook note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Retake Note Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_summary(self, data: dict, user_id: str):
        """
        Add a summary to a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service

            note_id = data.get("noteId")
            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            # Get the note
            note = await db.note.find_unique(where={"id": note_id})

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic and topic.note:
                    # It's a topicId, use the topic's note
                    print(f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}")
                    note = topic.note
                    note_id = note.id  # Update note_id to the actual note ID
                else:
                    return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to summarize"}

            # Strip any action blocks from content before summarizing
            cleaned_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                note.content,
                flags=re.DOTALL,
            ).strip()

            # Generate summary using AI
            summary = await llm_service.generate_summary(cleaned_content)

            # Update the note with summary in the summary field
            updated_note = await db.note.update(where={"id": note_id}, data={"summary": summary})

            return {
                "status": "success",
                "action": "add_summary",
                "note_id": updated_note.id,
                "message": f"Successfully added summary to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Summary Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_tags(self, data: dict, user_id: str):
        """
        Add tags to a note using AI.
        Expected data: { "noteId": "...", "tags": ["Tag1", "Tag2"] } (tags optional, will be generated if not provided)
        """
        try:
            from src.services.llm_service import llm_service
            from src.models.notes import NoteUpdate

            note_id = data.get("noteId")
            print(f"üì• Received action_data for add_tags: {data}")
            print(f"üîç Extracted noteId: {note_id}")
            print(f"üë§ User ID: {user_id}")

            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            print(f"üîç Looking up note with ID: {note_id}")
            # Get the note
            note = await db.note.find_unique(
                where={"id": note_id},
                include={
                    "tags": True,
                    "topic": {"include": {"module": {"include": {"course": True}}}},
                },
            )

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic:
                    if topic.note:
                        print(
                            f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}"
                        )
                        note = await db.note.find_unique(
                            where={"id": topic.note.id},
                            include={
                                "tags": True,
                                "topic": {"include": {"module": {"include": {"course": True}}}},
                            },
                        )
                        note_id = note.id if note else None
                    else:
                        return {
                            "status": "error",
                            "message": f"Topic '{topic.title}' exists but has no note. Please create a note first.",
                        }
                else:
                    return {"status": "error", "message": f"Note with ID {note_id} not found"}

            if not note:
                return {"status": "error", "message": f"Note with ID {note_id} not found"}

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            # Get existing tags
            existing_tags = [tag.tag for tag in note.tags] if note.tags else []
            print(f"üìã Existing tags: {existing_tags}")

            # Get tags from action data or generate them
            new_tags = data.get("tags")
            if not new_tags:
                # Generate tags using AI
                print("ü§ñ Generating tags using AI...")
                topic_title = None
                if note.topic:
                    topic_title = note.topic.title

                new_tags = await llm_service.generate_tags(
                    content=note.content or "",
                    title=note.title,
                    topic_title=topic_title,
                )
                print(f"‚ú® AI generated tags: {new_tags}")

            # Merge tags (avoid duplicates, case-insensitive)
            existing_lower = [t.lower() for t in existing_tags]
            merged_tags = existing_tags.copy()
            for tag in new_tags:
                if tag.lower() not in existing_lower:
                    merged_tags.append(tag)

            print(f"üìù Merged tags: {merged_tags}")

            # Update the note with merged tags
            # Remove existing tags
            await db.notetag.delete_many(where={"noteId": note_id})

            # Add merged tags
            for tag in merged_tags:
                await db.notetag.create(
                    data={
                        "noteId": note_id,
                        "tag": tag,
                    }
                )

            # Fetch updated note
            from src.services import note_service

            updated_note = await note_service.get_note(db, note_id, user_id)

            return {
                "status": "success",
                "action": "add_tags",
                "note_id": updated_note.id,
                "tags": merged_tags,
                "message": f"Successfully added tags to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Tags Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def recommend_resources(self, data: dict, user_id: str):
        """
        Generate and store resource recommendations using RAG.
        Expected data: { "query": "...", "topicId": "..." (optional), "courseId": "..." (optional), "limit": 10 }
        """
        print(f"üîµ [recommend_resources] START - User: {user_id}")
        print(f"üîµ [recommend_resources] Input data: {data}")
        print(f"üîµ [recommend_resources] User ID type: {type(user_id)}, value: {user_id}")

        try:
            from src.services.rag_service import rag_service
            from src.services.user_memory_service import user_memory_service

            query = data.get("query", "")
            topic_id = data.get("topicId")
            course_id = data.get("courseId")
            limit = data.get("limit", 10)

            print(
                f"üîµ [recommend_resources] Extracted params - query: '{query}', topicId: {topic_id}, courseId: {course_id}, limit: {limit}"
            )

            if not query:
                print("‚ùå [recommend_resources] ERROR: Query is empty")
                return {
                    "status": "error",
                    "message": "Query is required for resource recommendations",
                }

            # Get user context
            print(f"üîµ [recommend_resources] Fetching user context for user: {user_id}")
            user_context = await user_memory_service.get_user_context(user_id)
            print(f"üîµ [recommend_resources] User context retrieved: {list(user_context.keys())}")

            # Add topic/course context if provided
            if topic_id:
                print(f"üîµ [recommend_resources] Looking up topic: {topic_id}")
                topic = await db.topic.find_unique(
                    where={"id": topic_id}, include={"module": {"include": {"course": True}}}
                )
                if topic:
                    print(f"üîµ [recommend_resources] Topic found: {topic.title}")
                    user_context["currentTopic"] = {
                        "id": topic.id,
                        "title": topic.title,
                        "content": topic.content,
                    }
                    if topic.module and topic.module.course:
                        course_id = topic.module.course.id
                        print(f"üîµ [recommend_resources] Course ID from topic: {course_id}")
                        user_context["currentCourse"] = {
                            "id": topic.module.course.id,
                            "title": topic.module.course.title,
                        }
                else:
                    print(f"‚ö†Ô∏è [recommend_resources] Topic not found: {topic_id}")

            if course_id and "currentCourse" not in user_context:
                print(f"üîµ [recommend_resources] Looking up course: {course_id}")
                course = await db.course.find_unique(where={"id": course_id})
                if course:
                    print(f"üîµ [recommend_resources] Course found: {course.title}")
                    user_context["currentCourse"] = {
                        "id": course.id,
                        "title": course.title,
                    }
                else:
                    print(f"‚ö†Ô∏è [recommend_resources] Course not found: {course_id}")

            # Generate recommendations using RAG
            print("üîµ [recommend_resources] Generating recommendations via RAG service...")
            print(
                f"üîµ [recommend_resources] RAG params - query: '{query}', user_id: {user_id}, limit: {limit}"
            )
            recommendations = await rag_service.generate_recommendations(
                query=query,
                user_id=user_id,
                user_context=user_context,
                limit=limit,
            )
            print(
                f"üîµ [recommend_resources] RAG returned {len(recommendations) if recommendations else 0} recommendations"
            )

            # Validate user_id
            print(f"üîµ [recommend_resources] Validating user_id: {user_id} (type: {type(user_id)})")
            if not user_id:
                print("‚ùå [recommend_resources] ERROR: User ID is empty")
                return {
                    "status": "error",
                    "message": "User ID is required for resource recommendations",
                }

            # Verify user exists
            print("üîµ [recommend_resources] Verifying user exists in database...")
            user = await db.user.find_unique(where={"id": user_id})
            if not user:
                print(f"‚ùå [recommend_resources] ERROR: User not found: {user_id}")
                return {
                    "status": "error",
                    "message": f"User with ID {user_id} not found",
                }
            print(f"‚úÖ [recommend_resources] User verified: {user.email} (id: {user.id})")

            # Ensure user_id is a string (Prisma requirement)
            original_user_id = user_id
            user_id = str(user_id)
            if original_user_id != user_id:
                print(
                    f"üîµ [recommend_resources] Converted user_id from {type(original_user_id)} to string: {user_id}"
                )

            # Validate recommendations
            print(
                f"üîµ [recommend_resources] Validating recommendations - count: {len(recommendations) if recommendations else 0}, type: {type(recommendations)}"
            )
            if not recommendations or not isinstance(recommendations, list):
                print(
                    f"‚ùå [recommend_resources] ERROR: Invalid recommendations - {type(recommendations)}"
                )
                return {
                    "status": "error",
                    "message": "No recommendations generated",
                }
            print(f"‚úÖ [recommend_resources] Validated {len(recommendations)} recommendations")

            # Store recommendations as resources
            stored_resources = []
            for rec in recommendations:
                # Build recommendation reason
                reason_parts = []
                if topic_id:
                    topic_title = user_context.get("currentTopic", {}).get("title", "this topic")
                    reason_parts.append(f"for {topic_title}")
                elif course_id:
                    course_title = user_context.get("currentCourse", {}).get("title", "this course")
                    reason_parts.append(f"related to {course_title}")
                reason = " ".join(reason_parts) if reason_parts else None

                # Build metadata - ensure it's a valid JSON-serializable dict or None
                relevance = rec.get("relevance")
                print(
                    f"üîµ [recommend_resources] Relevance from rec: {relevance} (type: {type(relevance)})"
                )
                metadata = None
                if relevance is not None and relevance != "":
                    # Only create metadata if relevance has a valid value
                    # Ensure it's JSON-serializable
                    try:
                        json.dumps({"relevance": str(relevance)})  # Validate JSON serialization
                        metadata = {"relevance": str(relevance)}
                        print(f"üîµ [recommend_resources] Created metadata: {metadata}")
                    except (TypeError, ValueError) as e:
                        print(f"‚ö†Ô∏è [recommend_resources] Failed to create metadata: {e}")
                        metadata = None
                else:
                    print("üîµ [recommend_resources] No metadata (relevance is None or empty)")

                # Prepare resource data - ensure all required fields are set
                title = rec.get("title", "Untitled") or "Untitled"
                url = rec.get("url", "") or ""
                print(f"üîµ [recommend_resources] Title: '{title}', URL: '{url}'")

                if not url:
                    print(f"‚ö†Ô∏è [recommend_resources] Skipping resource with empty URL: {title}")
                    continue

                # Validate and normalize resource type
                resource_type = rec.get("type", "OTHER") or "OTHER"
                print(f"üîµ [recommend_resources] Resource type from rec: {resource_type}")
                valid_types = [
                    "VIDEO",
                    "ARTICLE",
                    "BOOK",
                    "COURSE",
                    "DOCUMENT",
                    "WEBSITE",
                    "PODCAST",
                    "OTHER",
                ]
                if resource_type.upper() not in valid_types:
                    print(
                        f"‚ö†Ô∏è [recommend_resources] Invalid resource type '{resource_type}', defaulting to OTHER"
                    )
                    resource_type = "OTHER"
                else:
                    resource_type = resource_type.upper()
                print(f"üîµ [recommend_resources] Final resource type: {resource_type}")

                # Validate and convert score to float
                raw_score = rec.get("score", 0.5)
                print(f"üîµ [recommend_resources] Raw score: {raw_score} (type: {type(raw_score)})")
                try:
                    score = float(raw_score)
                    # Ensure score is between 0 and 1
                    score = max(0.0, min(1.0, score))
                    print(f"üîµ [recommend_resources] Validated score: {score}")
                except (ValueError, TypeError) as e:
                    print(
                        f"‚ö†Ô∏è [recommend_resources] Score conversion failed: {e}, using default 0.5"
                    )
                    score = 0.5

                # Build resource data dictionary
                print("üîµ [recommend_resources] Building resource_data dictionary...")
                resource_data = {
                    "userId": user_id,
                    "title": title,
                    "url": url,
                    "type": resource_type,
                    "isRecommended": True,
                    "recommendationScore": score,
                    "recommendationSource": "ai",
                }
                print(
                    f"üîµ [recommend_resources] Base resource_data keys: {list(resource_data.keys())}"
                )
                print(
                    f"üîµ [recommend_resources] userId value: {resource_data['userId']} (type: {type(resource_data['userId'])})"
                )

                # Add optional fields - include None values explicitly (matches user_memory_service pattern)
                description = rec.get("description")
                print(
                    f"üîµ [recommend_resources] Description: {description} (type: {type(description)})"
                )
                resource_data["description"] = description

                if reason:
                    resource_data["recommendationReason"] = reason
                    print(f"üîµ [recommend_resources] Added recommendationReason: {reason}")
                if course_id:
                    resource_data["courseId"] = course_id
                    print(f"üîµ [recommend_resources] Added courseId: {course_id}")
                if topic_id:
                    resource_data["topicId"] = topic_id
                    print(f"üîµ [recommend_resources] Added topicId: {topic_id}")

                # Handle metadata - only include if not None (Prisma Python requirement)
                if metadata is not None:
                    # Ensure metadata is JSON-serializable
                    try:
                        json.dumps(metadata)  # Validate JSON serialization
                        resource_data["metadata"] = metadata
                        print(
                            f"üîµ [recommend_resources] Added metadata: {metadata} (type: {type(metadata)})"
                        )
                    except (TypeError, ValueError) as e:
                        print(
                            f"‚ö†Ô∏è [recommend_resources] Metadata not JSON-serializable: {e}, omitting"
                        )
                else:
                    print("üîµ [recommend_resources] Metadata is None, omitting from resource_data")

                # Log final resource_data structure
                print("üîµ [recommend_resources] Final resource_data structure:")
                for key, value in resource_data.items():
                    print(f"   - {key}: {value} (type: {type(value).__name__})")

                try:
                    # Ensure all required fields are present and properly typed
                    if not isinstance(user_id, str):
                        print("‚ö†Ô∏è [recommend_resources] Converting user_id to string")
                        user_id = str(user_id)
                        resource_data["userId"] = user_id

                    print("üîµ [recommend_resources] Attempting to create resource in database...")
                    print(
                        f"üîµ [recommend_resources] resource_data keys: {list(resource_data.keys())}"
                    )
                    print(
                        f"üîµ [recommend_resources] resource_data userId: {resource_data.get('userId')} (type: {type(resource_data.get('userId'))})"
                    )
                    print(
                        f"üîµ [recommend_resources] resource_data has metadata: {'metadata' in resource_data}"
                    )
                    if "metadata" in resource_data:
                        print(
                            f"üîµ [recommend_resources] metadata value: {resource_data['metadata']} (type: {type(resource_data['metadata'])})"
                        )

                    # Ensure userId is definitely a string
                    resource_data["userId"] = str(resource_data["userId"])

                    # Create resource - Prisma should handle None values for optional fields
                    resource = await db.resource.create(data=resource_data)
                    print(
                        f"‚úÖ [recommend_resources] Successfully created resource: {resource.id} - {resource.title}"
                    )

                    stored_resources.append(
                        {
                            "id": resource.id,
                            "title": resource.title,
                            "url": resource.url,
                            "description": resource.description,
                            "type": resource.type,
                            "score": score,
                        }
                    )
                    print(
                        f"‚úÖ [recommend_resources] Added to stored_resources list (total: {len(stored_resources)})"
                    )

                    # Index the resource in the background (don't fail if indexing fails)
                    try:
                        from src.services.indexing_service import indexing_service

                        print(f"üîµ [recommend_resources] Indexing resource {resource.id}...")
                        await indexing_service.index_resource(resource.id)
                        print("‚úÖ [recommend_resources] Resource indexed successfully")
                    except Exception as indexing_error:
                        print(
                            f"‚ö†Ô∏è [recommend_resources] Failed to index resource {resource.id}: {indexing_error}"
                        )
                        import traceback

                        traceback.print_exc()
                        # Continue processing other resources

                except Exception as create_error:
                    print(
                        f"‚ùå [recommend_resources] Failed to create resource '{title}': {create_error}"
                    )
                    print(f"‚ùå [recommend_resources] Error type: {type(create_error).__name__}")
                    import traceback

                    print("‚ùå [recommend_resources] Full traceback:")
                    traceback.print_exc()
                    print(f"‚ùå [recommend_resources] resource_data that failed: {resource_data}")
                    # Continue processing other resources
                    continue

            # Record interaction (don't fail if this fails)
            print("\nüîµ [recommend_resources] Recording interaction...")
            print(
                f"üîµ [recommend_resources] Interaction params - user_id: {user_id}, type: RECOMMENDATION_REQUESTED"
            )
            try:
                interaction_metadata = {
                    "query": query,
                    "recommendationCount": len(stored_resources),
                    "topicId": topic_id,
                    "courseId": course_id,
                }
                print(f"üîµ [recommend_resources] Interaction metadata: {interaction_metadata}")
                interaction_id = await user_memory_service.record_interaction(
                    user_id=user_id,
                    interaction_type="RECOMMENDATION_REQUESTED",
                    entity_type="chat",
                    metadata=interaction_metadata,
                    importance=0.7,
                )
                print(
                    f"‚úÖ [recommend_resources] Interaction recorded successfully: {interaction_id}"
                )
            except Exception as interaction_error:
                print(f"‚ö†Ô∏è [recommend_resources] Failed to record interaction: {interaction_error}")
                print(
                    f"‚ö†Ô∏è [recommend_resources] Interaction error type: {type(interaction_error).__name__}"
                )
                import traceback

                traceback.print_exc()
                # Continue - this is not critical

            # Return success even if some resources failed to create
            print("\nüîµ [recommend_resources] Final summary:")
            print(
                f"üîµ [recommend_resources] Total recommendations received: {len(recommendations)}"
            )
            print(
                f"üîµ [recommend_resources] Successfully created resources: {len(stored_resources)}"
            )

            if not stored_resources:
                print("‚ùå [recommend_resources] ERROR: No resources were created")
                return {
                    "status": "error",
                    "message": "No resources could be created from recommendations",
                }

            result = {
                "status": "success",
                "action": "recommend_resources",
                "resources": stored_resources,
                "count": len(stored_resources),
                "message": f"Successfully generated {len(stored_resources)} resource recommendations",
            }
            print(
                f"‚úÖ [recommend_resources] SUCCESS - Returning result with {len(stored_resources)} resources"
            )
            return result

        except Exception as e:
            print(f"‚ùå [recommend_resources] FATAL ERROR: {e}")
            print(f"‚ùå [recommend_resources] Error type: {type(e).__name__}")
            import traceback

            print("‚ùå [recommend_resources] Full traceback:")
            traceback.print_exc()
            return {"status": "error", "message": str(e)}


# Global Instance
action_service = ActionService()
