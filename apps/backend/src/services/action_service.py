"""
Action Service.
Executes structured actions triggered by the AI (e.g., creating courses).
"""

import json
import re

from prisma import Json  # <--- FIXED: Added this import
from src.core.database import db


class ActionService:
    async def execute_action(self, action_type: str, action_data: dict, user_id: str):
        """
        Route the action to the correct handler.
        """
        print(f"‚ö° EXECUTING ACTION: {action_type} for User {user_id}")

        if action_type == "create_course":
            return await self.create_course(action_data, user_id)
        elif action_type == "create_note":
            return await self.create_note(action_data, user_id)
        elif action_type == "retake_note":
            return await self.retake_note(action_data, user_id)
        elif action_type == "add_summary":
            return await self.add_summary(action_data, user_id)
        elif action_type == "add_tags":
            return await self.add_tags(action_data, user_id)
        elif action_type == "recommend_resources":
            return await self.recommend_resources(action_data, user_id)
        elif action_type == "create_goal":
            return await self.create_goal(action_data, user_id)
        elif action_type == "create_schedule":
            return await self.create_schedule(action_data, user_id)

        return {"status": "error", "message": f"Unknown action: {action_type}"}

    async def create_course(self, data: dict, user_id: str, progress_callback=None):
        """
        Creates a course with modules and topics in the DB.
        Expected data: { "title": "...", "modules": [ { "title": "...", "topics": [...] } ] }
        If modules are not provided, generates a course outline using LLM.

        Args:
            data: Course data dictionary
            user_id: User ID
            progress_callback: Optional async callback function(progress: int, stage: str, message: str, course_id: str = None)
        """
        course_id = None
        try:
            # Extract course info
            title = data.get("title", "AI Generated Course")
            description = data.get("description", "Generated by Maigie AI")
            difficulty = data.get("difficulty", "BEGINNER")
            modules_data = data.get("modules", [])

            # If no modules provided, generate course outline using LLM
            if not modules_data:
                from src.services.llm_service import llm_service

                print(f"üìö No modules provided, generating course outline for: {title}")

                if progress_callback:
                    await progress_callback(
                        20, "generating_outline", "Generating course outline..."
                    )

                # Extract topic from title (remove "Learning " prefix if present)
                topic = title.replace("Learning ", "").strip()

                # Generate outline
                outline = await llm_service.generate_course_outline(
                    topic=topic,
                    difficulty=difficulty,
                    user_message=None,
                )

                if progress_callback:
                    await progress_callback(
                        40, "outline_ready", "Course outline ready. Creating course structure..."
                    )

                # Use generated outline data
                modules_data = outline.get("modules", [])
                if outline.get("title"):
                    title = outline.get("title", title)
                if outline.get("description"):
                    description = outline.get("description", description)
                if outline.get("difficulty"):
                    difficulty = outline.get("difficulty", difficulty)

            # 1. Create the Course
            course = await db.course.create(
                data={
                    "userId": user_id,
                    "title": title,
                    "description": description,
                    "difficulty": difficulty,
                    "isAIGenerated": True,
                }
            )
            course_id = course.id

            if progress_callback:
                await progress_callback(
                    50, "creating_modules", f"Creating {len(modules_data)} modules...", course_id
                )

            # 2. Create Modules and Topics (Nested loop)
            total_modules = len(modules_data)
            for i, mod_data in enumerate(modules_data):
                module = await db.module.create(
                    data={
                        "courseId": course.id,
                        "title": mod_data.get("title", f"Module {i+1}"),
                        "order": float(i),
                        "description": mod_data.get("description"),
                    }
                )

                # Create Topics for this Module
                topics_data = mod_data.get("topics", [])
                for j, top_data in enumerate(topics_data):
                    await db.topic.create(
                        data={
                            "moduleId": module.id,
                            "title": (
                                top_data if isinstance(top_data, str) else top_data.get("title")
                            ),
                            "order": float(j),
                        }
                    )

                # Update progress after each module
                if progress_callback and total_modules > 0:
                    progress = 50 + int(((i + 1) / total_modules) * 40)
                    await progress_callback(
                        progress,
                        "creating_modules",
                        f"Created module {i + 1} of {total_modules}...",
                        course_id,
                    )

            if progress_callback:
                await progress_callback(95, "finalizing", "Finalizing course...", course_id)

            return {
                "status": "success",
                "action": "create_course",
                "course_id": course.id,
                "message": f"Successfully created course: {course.title}",
            }

        except Exception as e:
            print(f"‚ùå Action Failed: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def create_note(self, data: dict, user_id: str):
        """
        Creates a note for a topic.
        Expected data: { "title": "...", "content": "...", "topicId": "...", "summary": "..." (optional) }
        """
        try:
            from src.models.notes import NoteCreate
            from src.services import note_service

            # Validate topicId if provided
            topic_id = data.get("topicId")
            if topic_id:
                print(f"üîç Looking up topic with ID: {topic_id}")
                topic = await db.topic.find_unique(where={"id": topic_id})
                if not topic:
                    # Try to find any topic to see if it's a database issue
                    all_topics = await db.topic.find_many(take=1)
                    print(f"üîç Database has {len(all_topics)} topics (showing first as sample)")
                    if all_topics:
                        print(f"üîç Sample topic ID format: {all_topics[0].id}")
                    return {
                        "status": "error",
                        "message": f"Topic with ID {topic_id} not found",
                    }

                # Check if note already exists for this topic
                existing_note = await db.note.find_first(where={"topicId": topic_id})
                if existing_note:
                    return {
                        "status": "error",
                        "message": f"A note already exists for topic: {topic.title}",
                    }

            # Create note data
            note_data = NoteCreate(
                title=data.get("title", "Untitled Note"),
                content=data.get("content", ""),
                summary=data.get("summary"),
                topicId=topic_id,
                courseId=data.get("courseId"),
            )

            # Create the note
            note = await note_service.create_note(db, user_id, note_data)

            return {
                "status": "success",
                "action": "create_note",
                "note_id": note.id,
                "message": f"Successfully created note: {note.title}",
            }

        except ValueError as e:
            print(f"‚ùå Note Creation Failed: {e}")
            return {"status": "error", "message": str(e)}
        except Exception as e:
            print(f"‚ùå Note Creation Error: {e}")
            return {"status": "error", "message": str(e)}

    async def retake_note(self, data: dict, user_id: str):
        """
        Retake/rewrite a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service

            note_id = data.get("noteId")
            print(f"üì• Received action_data: {data}")
            print(f"üîç Extracted noteId: {note_id}")
            print(f"üë§ User ID: {user_id}")

            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            print(f"üîç Looking up note with ID: {note_id}")
            # Get the note
            note = await db.note.find_unique(where={"id": note_id})
            if note:
                print(f"‚úÖ Note found: {note.id} (title: {note.title}, userId: {note.userId})")
            else:
                print(f"‚ùå Note NOT FOUND with ID: {note_id}")

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic:
                    if topic.note:
                        # It's a topicId, use the topic's note
                        print(
                            f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}"
                        )
                        note = topic.note
                        note_id = note.id  # Update note_id to the actual note ID
                    else:
                        # Topic exists but has no note
                        return {
                            "status": "error",
                            "message": f"Topic '{topic.title}' exists but has no note. Please create a note first.",
                        }
                else:
                    return {
                        "status": "error",
                        "message": f"Note with ID {note_id} not found",
                    }

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {"status": "error", "message": "Note has no content to retake"}

            # Build context for AI
            context = {}
            if note.topicId:
                topic = await db.topic.find_unique(
                    where={"id": note.topicId},
                    include={"module": {"include": {"course": True}}},
                )
                if topic:
                    context["topicTitle"] = topic.title
                    if topic.module:
                        context["moduleTitle"] = topic.module.title
                        if topic.module.course:
                            context["courseTitle"] = topic.module.course.title
                            context["courseId"] = (
                                topic.module.course.id
                            )  # Include courseId from module->course

            # Strip any action blocks from the original content before rewriting
            cleaned_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                note.content,
                flags=re.DOTALL,
            ).strip()

            # Use AI to rewrite the content
            rewritten_content = await llm_service.rewrite_note_content(
                content=cleaned_content, title=note.title, context=context
            )

            # Strip any action blocks from the rewritten content (in case AI includes them)
            rewritten_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                rewritten_content,
                flags=re.DOTALL,
            ).strip()

            # Update the note
            updated_note = await db.note.update(
                where={"id": note_id}, data={"content": rewritten_content}
            )

            return {
                "status": "success",
                "action": "retake_note",
                "note_id": updated_note.id,
                "message": f"Successfully retook note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Retake Note Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_summary(self, data: dict, user_id: str):
        """
        Add a summary to a note using AI.
        Expected data: { "noteId": "..." }
        """
        try:
            from src.services.llm_service import llm_service

            note_id = data.get("noteId")
            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            # Get the note
            note = await db.note.find_unique(where={"id": note_id})

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic and topic.note:
                    # It's a topicId, use the topic's note
                    print(f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}")
                    note = topic.note
                    note_id = note.id  # Update note_id to the actual note ID
                else:
                    return {
                        "status": "error",
                        "message": f"Note with ID {note_id} not found",
                    }

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            if not note.content:
                return {
                    "status": "error",
                    "message": "Note has no content to summarize",
                }

            # Check summary generation limit for FREE tier users
            from src.services.usage_tracking_service import increment_feature_usage
            from src.utils.exceptions import SubscriptionLimitError

            try:
                user_obj = await db.user.find_unique(where={"id": user_id})
                if user_obj:
                    await increment_feature_usage(user_obj, "summary_generations", db_client=db)
            except SubscriptionLimitError as e:
                return {
                    "status": "error",
                    "message": e.message,
                }

            # Strip any action blocks from content before summarizing
            cleaned_content = re.sub(
                r"\s*<<<ACTION_START>>>.*?<<<ACTION_END>>>\s*",
                "",
                note.content,
                flags=re.DOTALL,
            ).strip()

            # Generate summary using AI
            summary = await llm_service.generate_summary(cleaned_content)

            # Update the note with summary in the summary field
            updated_note = await db.note.update(where={"id": note_id}, data={"summary": summary})

            return {
                "status": "success",
                "action": "add_summary",
                "note_id": updated_note.id,
                "message": f"Successfully added summary to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Summary Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def add_tags(self, data: dict, user_id: str):
        """
        Add tags to a note using AI.
        Expected data: { "noteId": "...", "tags": ["Tag1", "Tag2"] } (tags optional, will be generated if not provided)
        """
        try:
            from src.services.llm_service import llm_service

            note_id = data.get("noteId")
            print(f"üì• Received action_data for add_tags: {data}")
            print(f"üîç Extracted noteId: {note_id}")
            print(f"üë§ User ID: {user_id}")

            if not note_id:
                return {"status": "error", "message": "noteId is required"}

            print(f"üîç Looking up note with ID: {note_id}")
            # Get the note
            note = await db.note.find_unique(
                where={"id": note_id},
                include={
                    "tags": True,
                    "topic": {"include": {"module": {"include": {"course": True}}}},
                },
            )

            # If note not found, check if noteId is actually a topicId
            if not note:
                print(f"‚ö†Ô∏è Note with ID {note_id} not found, checking if it's a topicId...")
                topic = await db.topic.find_unique(
                    where={"id": note_id},
                    include={"note": True},
                )
                if topic:
                    if topic.note:
                        print(
                            f"‚úÖ Found topic with ID {note_id}, using its note ID: {topic.note.id}"
                        )
                        note = await db.note.find_unique(
                            where={"id": topic.note.id},
                            include={
                                "tags": True,
                                "topic": {"include": {"module": {"include": {"course": True}}}},
                            },
                        )
                        note_id = note.id if note else None
                    else:
                        return {
                            "status": "error",
                            "message": f"Topic '{topic.title}' exists but has no note. Please create a note first.",
                        }
                else:
                    return {
                        "status": "error",
                        "message": f"Note with ID {note_id} not found",
                    }

            if not note:
                return {
                    "status": "error",
                    "message": f"Note with ID {note_id} not found",
                }

            # Verify ownership
            if note.userId != user_id:
                return {"status": "error", "message": "Note not found or access denied"}

            # Get existing tags
            existing_tags = [tag.tag for tag in note.tags] if note.tags else []
            print(f"üìã Existing tags: {existing_tags}")

            # Get tags from action data or generate them
            new_tags = data.get("tags")
            if not new_tags:
                # Generate tags using AI
                print("ü§ñ Generating tags using AI...")
                topic_title = None
                if note.topic:
                    topic_title = note.topic.title

                new_tags = await llm_service.generate_tags(
                    content=note.content or "",
                    title=note.title,
                    topic_title=topic_title,
                )
                print(f"‚ú® AI generated tags: {new_tags}")

            # Merge tags (avoid duplicates, case-insensitive)
            existing_lower = [t.lower() for t in existing_tags]
            merged_tags = existing_tags.copy()
            for tag in new_tags:
                if tag.lower() not in existing_lower:
                    merged_tags.append(tag)

            print(f"üìù Merged tags: {merged_tags}")

            # Update the note with merged tags
            # Remove existing tags
            await db.notetag.delete_many(where={"noteId": note_id})

            # Add merged tags
            for tag in merged_tags:
                await db.notetag.create(
                    data={
                        "noteId": note_id,
                        "tag": tag,
                    }
                )

            # Fetch updated note
            from src.services import note_service

            updated_note = await note_service.get_note(db, note_id, user_id)

            return {
                "status": "success",
                "action": "add_tags",
                "note_id": updated_note.id,
                "tags": merged_tags,
                "message": f"Successfully added tags to note: {updated_note.title}",
            }

        except Exception as e:
            print(f"‚ùå Add Tags Error: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def recommend_resources(self, data: dict, user_id: str):
        """
        Generate and store resource recommendations using RAG.
        Expected data: { "query": "...", "topicId": "..." (optional), "courseId": "..." (optional), "limit": 10 }
        """
        print(f"üîµ [recommend_resources] START - User: {user_id}")

        try:
            from src.services.rag_service import rag_service
            from src.services.user_memory_service import user_memory_service

            query = data.get("query", "")
            topic_id = data.get("topicId")
            course_id = data.get("courseId")
            limit = data.get("limit", 10)

            if not query:
                return {
                    "status": "error",
                    "message": "Query is required for resource recommendations",
                }

            # Get user context
            user_context = await user_memory_service.get_user_context(user_id)

            # Add topic/course context if provided
            if topic_id:
                topic = await db.topic.find_unique(
                    where={"id": topic_id},
                    include={"module": {"include": {"course": True}}},
                )
                if topic:
                    user_context["currentTopic"] = {
                        "id": topic.id,
                        "title": topic.title,
                        "content": topic.content,
                    }
                    if topic.module and topic.module.course:
                        course_id = topic.module.course.id
                        user_context["currentCourse"] = {
                            "id": topic.module.course.id,
                            "title": topic.module.course.title,
                        }

            if course_id and "currentCourse" not in user_context:
                course = await db.course.find_unique(where={"id": course_id})
                if course:
                    user_context["currentCourse"] = {
                        "id": course.id,
                        "title": course.title,
                    }

            # Generate recommendations using RAG
            recommendations = await rag_service.generate_recommendations(
                query=query,
                user_id=user_id,
                user_context=user_context,
                limit=limit,
            )

            # Validate user_id
            if not user_id:
                return {
                    "status": "error",
                    "message": "User ID is required for resource recommendations",
                }

            # Verify user exists
            user = await db.user.find_unique(where={"id": user_id})
            if not user:
                return {
                    "status": "error",
                    "message": f"User with ID {user_id} not found",
                }

            # Ensure user_id is a string
            user_id = str(user_id)

            if (
                not recommendations
                or not isinstance(recommendations, list)
                or len(recommendations) == 0
            ):
                return {
                    "status": "success",
                    "message": f"I couldn't find specific resources for '{query}' at the moment. Try being more specific with your query, or I can help you search for different topics.",
                    "resources": [],
                    "action": "recommend_resources",
                }

            # Store recommendations as resources
            stored_resources = []
            for rec in recommendations:
                try:
                    # FIX: Strict Metadata Handling
                    # We ensure metadata is a valid Json object for Prisma
                    prisma_metadata = Json({})
                    relevance = rec.get("relevance")
                    if relevance:
                        # Create dict and wrap in Json()
                        clean_meta = {"relevance": str(relevance)}
                        prisma_metadata = Json(clean_meta)

                    # Build Resource Data
                    # FIX: Use 'userId' (scalar) only. Avoid 'user' relation object.
                    resource_data = {
                        "userId": str(user_id),
                        "title": rec.get("title", "Untitled") or "Untitled",
                        "url": rec.get("url", "") or "",
                        "type": (rec.get("type") or "OTHER").upper(),
                        "isRecommended": True,
                        "recommendationScore": float(rec.get("score", 0.5)),
                        "recommendationSource": "ai",
                        "description": rec.get("description"),
                        "metadata": prisma_metadata,  # <--- FIXED: Wrapped JSON
                    }

                    # Add optional context fields
                    reason_parts = []
                    if topic_id:
                        reason_parts.append(f"for topic {topic_id}")
                    if course_id:
                        reason_parts.append(f"related to course {course_id}")

                    if reason_parts:
                        resource_data["recommendationReason"] = " ".join(reason_parts)

                    if course_id:
                        resource_data["courseId"] = str(course_id)
                    if topic_id:
                        resource_data["topicId"] = str(topic_id)

                    # Skip empty URLs
                    if not resource_data["url"]:
                        continue

                    # Create resource in DB
                    resource = await db.resource.create(data=resource_data)
                    print(f"‚úÖ Created resource: {resource.title}")

                    # Add to result list
                    stored_resources.append(
                        {
                            "id": resource.id,
                            "title": resource.title,
                            "url": resource.url,
                            "description": resource.description,
                            "type": resource.type,
                            "score": resource.recommendationScore,
                        }
                    )

                    # Index in background
                    try:
                        from src.services.indexing_service import indexing_service

                        await indexing_service.index_resource(resource.id)
                    except Exception:
                        pass  # Ignore indexing errors

                except Exception as create_error:
                    print(f"‚ùå Failed to create resource: {create_error}")
                    continue

            # Record interaction
            try:
                interaction_metadata = {
                    "query": query,
                    "recommendationCount": len(stored_resources),
                    "topicId": topic_id,
                    "courseId": course_id,
                }
                await user_memory_service.record_interaction(
                    user_id=user_id,
                    interaction_type="RECOMMENDATION_REQUESTED",
                    entity_type="chat",
                    metadata=interaction_metadata,
                    importance=0.7,
                )
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to record interaction: {e}")

            if not stored_resources:
                return {
                    "status": "error",
                    "message": "No resources could be created from recommendations",
                }

            return {
                "status": "success",
                "action": "recommend_resources",
                "resources": stored_resources,
                "count": len(stored_resources),
                "message": f"Successfully generated {len(stored_resources)} resource recommendations",
            }

        except Exception as e:
            print(f"‚ùå [recommend_resources] FATAL ERROR: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def create_goal(self, data: dict, user_id: str):
        """
        Creates a goal for the user.
        Expected data: { "title": "...", "description": "..." (optional), "targetDate": "..." (optional), "courseId": "..." (optional), "topicId": "..." (optional) }
        """
        try:
            from datetime import datetime

            from src.services.user_memory_service import user_memory_service

            # Parse targetDate if provided
            target_date = None
            if data.get("targetDate"):
                try:
                    if isinstance(data["targetDate"], str):
                        target_date = datetime.fromisoformat(
                            data["targetDate"].replace("Z", "+00:00")
                        )
                    else:
                        target_date = data["targetDate"]
                except Exception as e:
                    print(f"Warning: Could not parse targetDate: {e}")

            # Build goal data, only including courseId/topicId if they have values
            goal_data = {
                "userId": user_id,
                "title": data.get("title", "AI Generated Goal"),
                "description": data.get("description"),
                "targetDate": target_date,
                "status": "ACTIVE",
            }

            # Only add courseId if it exists and is not None/empty
            course_id = data.get("courseId")
            if course_id:
                goal_data["courseId"] = course_id
                print(f"‚úÖ Including courseId in goal creation: {course_id}")
            else:
                print(f"‚ö†Ô∏è No courseId provided in data: {data.get('courseId')}")

            # Only add topicId if it exists and is not None/empty
            topic_id = data.get("topicId")
            if topic_id:
                goal_data["topicId"] = topic_id
                print(f"‚úÖ Including topicId in goal creation: {topic_id}")

            print(f"üìù Creating goal with data: {goal_data}")

            # Create the goal
            goal = await db.goal.create(data=goal_data)

            print(
                f"‚úÖ Goal created: id={goal.id}, courseId={getattr(goal, 'courseId', None)}, topicId={getattr(goal, 'topicId', None)}"
            )

            # Record interaction for user memory
            await user_memory_service.record_interaction(
                user_id=user_id,
                interaction_type="GOAL_CREATE",
                entity_type="goal",
                entity_id=goal.id,
                importance=0.7,
            )

            return {
                "status": "success",
                "action": "create_goal",
                "goal_id": goal.id,
                "message": f"Successfully created goal: {goal.title}",
            }

        except Exception as e:
            print(f"‚ùå Goal Creation Failed: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}

    async def create_schedule(self, data: dict, user_id: str):
        """
        Creates a schedule block for the user.
        Expected data: {
            "title": "...",
            "description": "..." (optional),
            "startAt": "..." (ISO format),
            "endAt": "..." (ISO format),
            "recurringRule": "..." (optional, e.g., "DAILY", "WEEKLY", "RRULE:..."),
            "courseId": "..." (optional),
            "topicId": "..." (optional),
            "goalId": "..." (optional)
        }
        """
        try:
            from datetime import datetime

            from src.services.user_memory_service import user_memory_service

            # Parse startAt and endAt
            start_at = None
            if data.get("startAt"):
                try:
                    if isinstance(data["startAt"], str):
                        start_at = datetime.fromisoformat(data["startAt"].replace("Z", "+00:00"))
                    else:
                        start_at = data["startAt"]
                except Exception as e:
                    print(f"Warning: Could not parse startAt: {e}")
                    return {"status": "error", "message": f"Invalid startAt format: {e}"}

            end_at = None
            if data.get("endAt"):
                try:
                    if isinstance(data["endAt"], str):
                        end_at = datetime.fromisoformat(data["endAt"].replace("Z", "+00:00"))
                    else:
                        end_at = data["endAt"]
                except Exception as e:
                    print(f"Warning: Could not parse endAt: {e}")
                    return {"status": "error", "message": f"Invalid endAt format: {e}"}

            if not start_at or not end_at:
                return {
                    "status": "error",
                    "message": "startAt and endAt are required",
                }

            if end_at <= start_at:
                return {
                    "status": "error",
                    "message": "endAt must be after startAt",
                }

            # Build schedule data
            schedule_data = {
                "userId": user_id,
                "title": data.get("title", "AI Generated Schedule Block"),
                "description": data.get("description"),
                "startAt": start_at,
                "endAt": end_at,
                "recurringRule": data.get("recurringRule"),
            }

            # Only add courseId if it exists and is not None/empty
            course_id = data.get("courseId")
            if course_id:
                # Verify course exists and belongs to user
                course = await db.course.find_first(where={"id": course_id, "userId": user_id})
                if course:
                    schedule_data["courseId"] = course_id
                else:
                    print(f"‚ö†Ô∏è Course not found: {course_id}")

            # Only add topicId if it exists and is not None/empty
            topic_id = data.get("topicId")
            if topic_id:
                topic = await db.topic.find_first(where={"id": topic_id})
                if topic:
                    schedule_data["topicId"] = topic_id
                else:
                    print(f"‚ö†Ô∏è Topic not found: {topic_id}")

            # Only add goalId if it exists and is not None/empty
            goal_id = data.get("goalId")
            if goal_id:
                goal = await db.goal.find_first(where={"id": goal_id, "userId": user_id})
                if goal:
                    schedule_data["goalId"] = goal_id
                else:
                    print(f"‚ö†Ô∏è Goal not found: {goal_id}")

            print(f"üìÖ Creating schedule with data: {schedule_data}")

            # Check for calendar conflicts if user has calendar connected
            from src.services.google_calendar_service import google_calendar_service

            conflict_warning = None
            user = await db.user.find_unique(where={"id": user_id})
            if user and user.googleCalendarSyncEnabled:
                conflict_check = await google_calendar_service.has_conflict(
                    user_id=user_id,
                    start_time=start_at,
                    end_time=end_at,
                )
                if conflict_check.get("has_conflict"):
                    busy_periods = conflict_check.get("busy_periods", [])
                    conflict_warning = (
                        f"‚ö†Ô∏è Note: This time slot ({start_at.strftime('%I:%M %p')} - "
                        f"{end_at.strftime('%I:%M %p')}) conflicts with existing calendar events. "
                        f"Found {len(busy_periods)} conflicting event(s)."
                    )
                    print(f"‚ö†Ô∏è Schedule conflict detected: {conflict_warning}")

            # Create the schedule block
            schedule = await db.scheduleblock.create(data=schedule_data)

            print(f"‚úÖ Schedule Created: {schedule.id} - {schedule.title}")

            # Sync with Google Calendar if enabled
            if user and user.googleCalendarSyncEnabled:
                try:
                    await google_calendar_service.create_event(
                        user_id=user_id,
                        schedule_id=schedule.id,
                        title=schedule.title,
                        description=schedule.description,
                        start_at=start_at,
                        end_at=end_at,
                        recurring_rule=data.get("recurringRule"),
                    )
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to sync schedule to Google Calendar: {e}")

            # Record interaction for user memory
            await user_memory_service.record_interaction(
                user_id=user_id,
                interaction_type="SCHEDULE_CREATE",
                entity_type="schedule",
                entity_id=schedule.id,
                importance=0.7,
            )

            response = {
                "status": "success",
                "message": "Schedule block created successfully",
                "schedule": {
                    "id": schedule.id,
                    "title": schedule.title,
                    "startAt": schedule.startAt.isoformat(),
                    "endAt": schedule.endAt.isoformat(),
                },
            }

            # Add conflict warning if present
            if conflict_warning:
                response["warning"] = conflict_warning

            return response

        except Exception as e:
            print(f"‚ùå Schedule Creation Failed: {e}")
            import traceback

            traceback.print_exc()
            return {"status": "error", "message": str(e)}


# Global Instance
action_service = ActionService()
