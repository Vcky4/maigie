name: Soprano TTS Service Deployment

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      preview_id:
        required: false
        type: string
      image_tag:
        required: true
        type: string
      output_file:
        required: true
        type: string
    outputs:
      image_built:
        value: ${{ jobs.build-and-save.outputs.image_built }}
      image_file:
        value: ${{ jobs.build-and-save.outputs.image_file }}

  push:
    branches: [main, development]
    paths:
      - apps/soprano-tts-service/**
  pull_request:
    branches: [main, development]
    paths:
      - apps/soprano-tts-service/**
    types: [opened, synchronize, reopened, closed]

permissions:
  contents: read

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.changes.outputs.soprano }}
    steps:
      - uses: actions/checkout@v4
      - id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            soprano:
              - apps/soprano-tts-service/**

  build-and-save:
    needs: check-changes
    runs-on: ubuntu-latest
    if: needs.check-changes.outputs.has-changes == 'true' || github.event_name == 'workflow_call'
    outputs:
      image_built: ${{ steps.meta.outputs.built }}
      image_file: ${{ steps.meta.outputs.image_file }}

    steps:
      - uses: actions/checkout@v4

      # ðŸ”¹ ONE cleanup only (safe + fast, preserves cache)
      - name: Initial Docker cleanup
        run: |
          docker system prune -f || true
          docker buildx prune -f || true
          df -h

      - uses: docker/setup-buildx-action@v3

      - name: Create buildx builder instance
        run: |
          docker buildx create --name builder --driver docker-container --use || \
          docker buildx use builder || true
          docker buildx inspect --bootstrap || true

      - name: Determine build metadata
        id: meta
        run: |
          if [ "${{ github.event_name }}" = "workflow_call" ]; then
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "image_file=${{ inputs.output_file }}" >> $GITHUB_OUTPUT
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "preview_id=${{ inputs.preview_id }}" >> $GITHUB_OUTPUT
            echo "built=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            ID=${{ github.event.pull_request.number }}
            echo "tag=maigie-soprano-tts-preview:${ID}" >> $GITHUB_OUTPUT
            echo "image_file=soprano-preview-image.tar.gz" >> $GITHUB_OUTPUT
            echo "environment=preview" >> $GITHUB_OUTPUT
            echo "preview_id=${ID}" >> $GITHUB_OUTPUT
            echo "built=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "tag=maigie-soprano-tts:latest" >> $GITHUB_OUTPUT
            echo "image_file=soprano-production-image.tar.gz" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "built=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/development" ]; then
            echo "tag=maigie-soprano-tts:staging" >> $GITHUB_OUTPUT
            echo "image_file=soprano-staging-image.tar.gz" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "built=true" >> $GITHUB_OUTPUT
          else
            echo "built=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Docker image
        if: steps.meta.outputs.built == 'true'
        working-directory: apps/soprano-tts-service
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_PROGRESS: plain
        run: |
          docker buildx build \
            --builder builder \
            --platform linux/amd64 \
            --tag ${{ steps.meta.outputs.tag }} \
            --load \
            --cache-from type=gha,scope=soprano-tts-${{ steps.meta.outputs.environment }} \
            --cache-to type=gha,mode=max,scope=soprano-tts-${{ steps.meta.outputs.environment }} \
            --progress=plain \
            .

      - name: Save image
        if: steps.meta.outputs.built == 'true'
        run: |
          docker save ${{ steps.meta.outputs.tag }} | gzip > ${{ steps.meta.outputs.image_file }}
          ls -lh ${{ steps.meta.outputs.image_file }}

      - name: Upload artifact
        if: steps.meta.outputs.built == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: soprano-tts-${{ steps.meta.outputs.environment }}
          path: ${{ steps.meta.outputs.image_file }}
          retention-days: 1

      # ðŸ”¹ Preview VPS upload with retry logic and validation
      - name: Upload preview image to VPS
        if: steps.meta.outputs.environment == 'preview'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/vps_key
          chmod 600 ~/.ssh/vps_key
          
          # Retry ssh-keyscan with delays to handle connection issues
          for i in {1..5}; do
            if ssh-keyscan -H -T 10 ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "Successfully added host key"
              break
            else
              echo "Attempt $i failed, retrying in 2 seconds..."
              sleep 2
            fi
          done
          
          # Verify known_hosts was populated
          if [ ! -s ~/.ssh/known_hosts ]; then
            echo "Warning: Could not add host key, but continuing since StrictHostKeyChecking=no is used"
          fi

          # Upload image with validation
          echo "Uploading ${{ steps.meta.outputs.image_file }} to VPS..."
          LOCAL_SIZE=$(stat -c%s "${{ steps.meta.outputs.image_file }}" 2>/dev/null || stat -f%z "${{ steps.meta.outputs.image_file }}" 2>/dev/null || du -b "${{ steps.meta.outputs.image_file }}" | cut -f1)
          
          scp -i ~/.ssh/vps_key -o StrictHostKeyChecking=no \
            ${{ steps.meta.outputs.image_file }} \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/soprano.tar.gz

          # Verify upload and load image
          ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no \
            ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} \
            "REMOTE_SIZE=\$(stat -c%s /tmp/soprano.tar.gz 2>/dev/null || stat -f%z /tmp/soprano.tar.gz 2>/dev/null || du -b /tmp/soprano.tar.gz | cut -f1) && \
             echo \"Local size: $LOCAL_SIZE bytes\" && \
             echo \"Remote size: \$REMOTE_SIZE bytes\" && \
             if [ \"\$REMOTE_SIZE\" -eq \"$LOCAL_SIZE\" ]; then \
               echo 'âœ“ File sizes match'; \
               docker load < /tmp/soprano.tar.gz && \
               rm /tmp/soprano.tar.gz && \
               echo 'âœ“ Image loaded successfully' && \
               docker images --format '{{.Repository}}:{{.Tag}}' | grep '${{ steps.meta.outputs.tag }}' || echo 'Warning: Image tag not found after load'; \
             else \
               echo 'âŒ File size mismatch - transfer may be incomplete'; \
               rm -f /tmp/soprano.tar.gz; \
               exit 1; \
             fi"

      # ðŸ”¹ Final cleanup (ONCE)
      - name: Final cleanup
        if: always()
        run: |
          docker rmi ${{ steps.meta.outputs.tag }} || true
          rm -f ${{ steps.meta.outputs.image_file }} || true
          docker system prune -f || true
          df -h

  skip-build:
    needs: check-changes
    runs-on: ubuntu-latest
    if: needs.check-changes.outputs.has-changes == 'false' && github.event_name != 'workflow_call'
    steps:
      - run: echo "No Soprano changes detected â€” skipping build"
